---
layout: post
title: 백준(4811) 알약
categories : algorithm
---

----
<br><br>

## 1. 문제 
<br>
[백준 알약 문제(4811)](https://www.acmicpc.net/problem/4811)  


문제를 요약하자면 먼저 병에는 N개의 알약이 존재한다. 하루에 반알씩 약을 복용해야 한다. 한 알 전체를 꺼낼 경우 반으로 쪼갠 후 나머지 조각을 병에 다시 넣고, 반 조각을 꺼낼 경우 그 약을 먹는다. 이때 한 조각을 꺼낼 경우 W, 반 조각을 꺼낼 경우 H를 종이에 기록한다. 2N일이 지났을 때 가능한 서로 다른 문자열의 개수를 구해야 한다. 

<br><br>

## 2. 코드 (Python 3) 
<br>
```
import sys
input=sys.stdin.readline
dp  = [[1]*31 if i == 0 else [0]*31 for i in range (31)]
m = 30

for i in range (1,31):
  for j in range(m):
    if j == 0:
      dp[i][0] = dp[i-1][1]
    else:
      dp[i][j] = dp[i-1][j+1] + dp[i][j-1] 
  m-=1

n = int (input ())
while n != 0:  
  print (dp[n][0])
  n = int (input())
```
<br><br>

## 3. 풀이
<br>
문제가 재귀호출을 사용하는 문제로 분류되어 있어, 처음에는 단순 재귀호출을 사용하여 문제를 해결하고자 했다. 먼저 $F(N,M)$ 는 알약 N 조각과 2등분 된 알약 M 조각이 있을 때 만들어지는 서로 다른 문자열의 개수라고 하자. 만약 알약 통에 각각 N,M 개의 알약이 존재한다면, 등분 되지 않은 알약을 꺼내는 경우와 조각 난 알약을 꺼내는 경우로 나눌 수 있다. 따라서 아래와 같은 점화식을 세울 수 있다. 
<br>

$$
F(N,M) = F(N-1,M+1) + F(N,M-1)
$$

<br>
처음에는 위 식에 따라 몇가지 조건식을 넣고 recursion 코드를 구현했더니, 중복되는 계산이 많아서 주어진 시간 안에 문제를 풀 수 없을 것 같았다. 따라서 DP를 사용했고 그 중에 `Bottom-up` 방식으로 다시 문제를 풀게 되었다. 

<br>

$$  F(N,M) =
\begin{cases}
F(N-1,M+1),  & \text{if $N > 0$ and $M = 0 $}\\
1, & \text{if $N = 0$ and $M > 0$} \\
F(N-1,M+1) + F(N,M-1), & \text{if $N > 0$ and $M > 0$}
\end{cases}$$

<br>

위 식에 따라 2 X 2 배열을 생성하였고, 입력으로 N(30 이하 정수)이 주어질 때 마다 배열에서 해당 답인 DP[N][0] (나눠지지 않은 알약 N) 찾아서 출력하였다.  
<br>

## 4. 시간복잡도 
<br>

테스트케이스 수와 상관 없이 2차원 배열을 생성해야 하기 때문에 시간복잡도는 $O(N^2)$이다.
<br><br>


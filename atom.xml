<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Yu's Tech 블로그</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2021-03-21T20:12:10+09:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Jaeseo Yu</name>
   <email></email>
 </author>

 
 <entry>
   <title>parellel programming</title>
   <link href="http://localhost:4000/opencl/2019/10/08/Parellel-programming/"/>
   <updated>2019-10-08T00:00:00+09:00</updated>
   <id>http://localhost:4000/opencl/2019/10/08/ Parellel programming</id>
   <content type="html">&lt;hr /&gt;

&lt;p&gt;What are 3 traditional ways HW designers make computers run faster?&lt;/p&gt;

&lt;p&gt;빠르게 구멍을 파고 싶을 때&lt;/p&gt;

&lt;p&gt;1) 삽질을 빨리한다. 
2) 생산성이 높은 삽을 얻는다(한 개의 삽에 삽 헤드가 여러 개)
3) 여러 명의 도움을 얻는다&lt;/p&gt;

&lt;p&gt;각각을 Computation 문제에 적용하면&lt;/p&gt;

&lt;p&gt;1) Clock을 빠르게 한다(shorter time for each computation) -&amp;gt; power comsumption 증가 
2) Instruction 단위 parallelism per cycle -&amp;gt; 생산성 증대에 한계
3) many weaker less powerful processors&lt;/p&gt;

&lt;p&gt;modern gpu&lt;/p&gt;

&lt;p&gt;1) thousands of ALUs (수 천개의 연산을 동시에 수행)
2) hundreds of processors ()
3) tens of thousands of concurrent threads (동시 수행 흐름을 갖는다)&lt;/p&gt;

&lt;p&gt;=&amp;gt; 하지만 gpu를 사용하여 성능을 증가시키기 위하여 parallel하게 프로그래밍을 해야한다.&lt;/p&gt;

&lt;p&gt;Minimize time spent on memory&lt;/p&gt;

&lt;p&gt;=&amp;gt; move frequetly-accessed data to fast memory&lt;/p&gt;

&lt;p&gt;local (특정 thread에 속함 - local variable 등) &amp;gt; shared(thread block) » global(all thread) » CPU(host memory)&lt;/p&gt;

&lt;p&gt;local은 보통 레지스터나 l1 cache에 존재한다.&lt;/p&gt;

&lt;p&gt;coalesce global memory accesses&lt;/p&gt;

&lt;p&gt;GPU most efficient when threads read or write contiguous  memory locations&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenCL과 4가지 모델</title>
   <link href="http://localhost:4000/opencl/2019/08/30/OpenCL%EC%9D%B4%EB%9E%80/"/>
   <updated>2019-08-30T00:00:00+09:00</updated>
   <id>http://localhost:4000/opencl/2019/08/30/ OpenCL이란</id>
   <content type="html">&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;1opencl&quot;&gt;1.OpenCL&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;OpenCL(Open Computing Language)&lt;/strong&gt;은 CPU, GPU, DSP 등 다양한 하드웨어 자원을 활용하여 프로그래밍을 하기 위한 산업 표준 병렬 프레임워크이다. 비영리 컨소시엄인 크로노스 그룹(Khronos Group)이 관리하고 있으며 여러 제조사에서 만들어진 하드웨어로 이루어진 시스템에까지 효과적으로 활용될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2opencl-4가지-모델&quot;&gt;2.OpenCL 4가지 모델&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
OpenCL의 architecture를 4가지 개념적 모델로서 구분하여 설명한다. 
&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Platform model&lt;/li&gt;
    &lt;li&gt;Execution model&lt;/li&gt;
    &lt;li&gt;Memory model&lt;/li&gt;
    &lt;li&gt;Programming model&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-1-platform-model&quot;&gt;2-1. Platform model&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
 OpenCL에서 사용되는 heterogeneous한 platform들을 high-level한 관점에서 나타낸 것이다. host와 device들로 구성되어 있으며 host는 OpenCL 외부 환경과의 상호작용을 담당한다. 예를 들어 I/O나 프로그램 유저와의 소통 창구 역할을 하는 것이다. 이러한 host는 여러 OpenCL device들과 연결되어 있다. 이러한 device는 compute device로 불리기도 하며, CPU, GPU, DSP등 여러 프로세서를 포함한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OpenCL device&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compute units&lt;/code&gt;로 나뉘고 이는 다시 실제 연산이 수행되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processing elements(PEs)&lt;/code&gt;로 나뉘게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-2-execution-model&quot;&gt;2-2. Execution model&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;OpenCL execution model은 어떻게 kernel이 실행되는지를 정의한다.&lt;/strong&gt; OpenCL application은 host program과 하나 이상의 kernels로 이루어져 있다. kernel들은 OpenCL device에서 실행되며 input memory object를 입력받아 처리를 거친 후 output memory object를 리턴한다.&lt;/p&gt;

&lt;p&gt;Host program은 OpenCL device에 kernel을 할당하는 명령어를 실행한다. 그러면 OpenCL 런타임은 integer index space를 만들고 각 kernel의 instance들이 해당 index space위에서 실행된다. 이렇게 실행중인 kernel을 &lt;strong&gt;work-item&lt;/strong&gt;이라고 부른다. 그리고 이 work-item들이 모여서 &lt;strong&gt;work-group&lt;/strong&gt;을 구성하게 된다. work-item과 work-group은 고유의 id 값을 가지며 각 work-item은 해당 아이템이 속한 work-group 내에서 마찬가지로 id를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;+커널은 어떻게 실행이 되는가?&lt;/strong&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Kernel을 실행하기 위해서는 먼저 각 device마다 할당되어 있는 queue에 해당 &lt;em&gt;kernel&lt;/em&gt;을 enqueue해야 한다. 이 때 사용하는 OpenCL API는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enqueueNDRangeKernel()&lt;/code&gt;이다. 해당 API를 호출할 때 핵심적인 3가지 arguments는 Kernel object, work-items의 수(global size), work-group당 work-item의 수 (local size)이다. 해당 명령어를 통해 host program이 OpenCL device에 실행되어야 할 kernel을 전달하게 되고 OpenCL runtime은 integer index space를 구성하게 된다. 실행 중인 kernel을 &lt;em&gt;work item&lt;/em&gt;이라고 하며 동일한 instruction sequence를 갖는다.이는 index 공간의 좌표를 통해 식별된다. 이러한 좌표는 work-item의 global id이다. work item들이 모여서 &lt;em&gt;work group&lt;/em&gt;을 형성하게 된다. work group은 대응되는 각 dimension에 대해 같은 size를 갖고 global size를 균등하게 나누게 된다. work-group내의 work-item은 단일 compute unit의 processing unit들에서 &lt;em&gt;concurrent&lt;/em&gt;하게 실행된다. index space는 N-dimension을 갖는 일정 값의 범위에 존재하는데, 이를 &lt;em&gt;NDRange&lt;/em&gt;라고 부른다. 그리고 N은 1,2,3 으로 설정될 수 있다. NDRange는 길이 N의 integer array이며 각 element는 각 dimension의 index space의 size를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Q라는 queue에 K라는 kernel object를 넣는다. 
Q.enqueueNDRangeKernel(K, NullRange, NDRange(1024), NDRange(128));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
위의 코드는 1024개의 work-item을 생성하고 각 work-group에 128개의 work-item을 할당한다. 따라서 1024/128 = 8개의 work-group이 생성되게 된다.
&lt;br /&gt;
OpenCL C kernel 코드는 single work-item에 대응된다. work-item의 granuality는 프로그래머가 필요에 따라 설정하게 된다. 아래는 1024개의 elements를 담은 두 array의 합을 구하는 kernel 코드이다.&lt;/p&gt;

&lt;p&gt;1) work-item마다 1개의 array element를 더하는 예제
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kernel vectorAdd(global int* A, global const int * B)
{
    int gid = get_global_id(0);
    A[gid] += B[gid];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
2) work-item마다 16개의 array elements을 더하는 예제
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define ITER 16

kernel vectorAdd(global int* A, global const int * B)
{
    int gid = get_global_id(0) * ITER;
    int i;
    for (i = 0; i &amp;lt; ITER; ++i)
    {
        A[gid + i] += B[gid+ i];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;첫번째 예제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enqueueNDRangeKernel()&lt;/code&gt;를 호출할 때 1024를 global size로 설정한다. 두 번째 kernel은 각 work-item마다 16개의 elements를 더하기 때문에 64(1024/16)를 global size로 설정한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Work-group 실행&lt;/strong&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Event ev;
Q.enqueueNDRangeKernel(K, NullRange, NDRange(8), NDRange(1), NULL, &amp;amp;ev);
concurrent();
ev.wait()
post();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2번째 code line이 실행되면, kernel이 command-queue Q에 들어간다. 그리고 해당 command가 return 하고 나서 3번째 줄의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;conccurent()&lt;/code&gt;가 실행된다.&lt;/p&gt;

&lt;p&gt;이 때 비동기적으로 OpenCL runtime은 command-queue를 모니터링한다. command-queue에 kernel이 들어오고 모든 dependencies가 만족된 상태이면 요청된 kernel에 맞는 수의 work-groups을 생성한 후 command-queue와 연결된 device의 work-group queue에 넣는다.&lt;/p&gt;

&lt;p&gt;각 device의 core(compute unit)는 device에 할당된 &lt;em&gt;work-group queue&lt;/em&gt;에서 work-group을 뽑는다. 그리고 뽑은 work-group을 각 compute unit에서 실행시키며, queue에 있는 모든 work-group을 전부 뽑을 때 까지 이 과정을 반복한다.&lt;/p&gt;

&lt;p&gt;host CPU는 concurrent()를 실행하고 다른 프로세서(ex. DSP)의 cores는 concurrently work-group들을 실행하게 된다. 만약 host가 concurrent 함수를 먼저 끝냈다고 할 때, 4번째 command가 실행되게 된다. 이 때 kernel submission과 관련된 ev가 CL_COMPLETE가 될 때까지 host는 wait을 하게 된다. 이후 OpenCL runtime은 kernel K에 대한 모든 work-group들이 완료되면 ev의 status를 CL_COMPLETE로 변환하게 되고 host가 5번째 command인 post()를 실행하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Work-group 내의 Work-item 실행&lt;/strong&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞에서 말했듯이 kernel function은 single work-item에 대응된다. 해당 work-item들이 실행되는 device의 hardware architecture에 따라 work-item의 수행에 대한 OpenCL 구현이 다르다. 어떠한 architecture에서는 work-item이 concurrently하게 실행되고 어떤 architecture에서는 sequentially하게 수행된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Context&lt;/em&gt;는 kernel이 정의되고 실행되는 환경을 정의한다. host는 kernel을 정의하고 이에 맞는 context를 생성한다. Context는 아래의 4가지 요소의 측면에서 정의된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Devices&lt;/li&gt;
  &lt;li&gt;Kernels&lt;/li&gt;
  &lt;li&gt;Program objects&lt;/li&gt;
  &lt;li&gt;Memory objects&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Context&lt;/em&gt;는 host가 OpenCL API를 이용하여 생성하고 조작한다. host는 cpu 내의 특정 core에서 작동하게 된다. host는 heterogeneous platform 내에서 어떤 하드웨어 자원이 사용 가능한지 파악한다. 그리고 host는 실행해야 할 kernel과 문제에 맞게 하드웨어 자원의 조합을 결정한다. 이후 host는 선택된 devices를 context내에 정의하게 된다.&lt;/p&gt;

&lt;p&gt;또한 하나 이상의 &lt;em&gt;Program objects&lt;/em&gt;이 context에 포함된다. Program object는 kernel을 구현한 source code와 executables을 담고 있다. 이러한 program object는 runtime에 생성된다. runtime에 object가 생성되는 이유는 OpenCL 개발자들은 end user가 어떠한 하드웨어 자원 위에서 프로그램을 실행할지 모르기 때문이다. 따라서 context에 devices가 정의되면, host는 이에 맞게 source code를 컴파일하는 방법을 정하게 되고 kernel를 위한 코드를 생성하게 된다.&lt;/p&gt;

&lt;p&gt;마지막으로 kernel 코드를 실행하는데 필요한 메모리 자원이 필요하다. 하지만 devices들은 저마다 서로 다른 memory architecture를 가지고 있으며 이러한 문제에 대처하기 위해서 OpenCL은 &lt;em&gt;Memory objects&lt;/em&gt; 라는 개념을 정의하고 사용한다. 이 objects는 host에서 정의되며 devices 간, host와 device 사이에서 필요에 의해 전달되며 사용된다. memory objects의 개념으로 OpenCL은 더 많고 다양한 platform을 지원할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Memory Model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;OpenCL은 *buffer objects&lt;/em&gt;와 &lt;em&gt;image object&lt;/em&gt;라는 2가지 타입의 memory object를 정의한다. 이는 kernel이 사용할 수 있는 contiguous한 메모리 블록이다. Image object는 OpenCL의 built-in support로서 다양한 format의 image data를 처리하는 과정에서 데이터 표현과 접근을 더 쉽고 간단하게 해준다. OpenCL model은 메모리 영역을 5가지로 구분한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Host memory : Host에게만 보이는 메모리 영역이다.&lt;/li&gt;
  &lt;li&gt;Global memory : 모든 work-group의 모든 work-item들이 read/write 접근을 할 수 있는 메모리 영역이다.&lt;/li&gt;
  &lt;li&gt;Constant memory : Global memory 영역에 속해있는 영역으로서 kernel 실행 동안 constant하게 유지된다. host가 constant memory를 할당하고 초기화하며 work-item은 해당 영역의 objects에 read-only access만 가능하다.&lt;/li&gt;
  &lt;li&gt;Local memory : 이 메모리 영역은 work-group에 속한다. 따라서 이 영역의 variable들은 특정 work-group의 work-item들 간에 공유가 된다.&lt;/li&gt;
  &lt;li&gt;Private memory : 이 메모리 영역은 특정 work-item을 위하여 할당되며 다른 work-item은 해당 영역을 볼 수 없다.&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>MongoDB replset으로 변환</title>
   <link href="http://localhost:4000/mongodb/2019/02/21/MongoDB-replset%EC%9C%BC%EB%A1%9C-%EB%B3%80%ED%99%98/"/>
   <updated>2019-02-21T00:00:00+09:00</updated>
   <id>http://localhost:4000/mongodb/2019/02/21/MongoDB replset으로 변환</id>
   <content type="html">&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-도입-&quot;&gt;1. 도입 :&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;MongoDB 3.6 version 이후 도입된 &lt;strong&gt;Change Stream&lt;/strong&gt; 기능은 DB의 변경 사항을 real time으로 관찰할 수 있게 해준다. 즉 프로그램은 Change Stream을 통해서
DB의 변화를 감지하고 그에 따른 Response를 할 수 있다. 단일 Collection부터 Database뿐만 아니라 배포한 모든 것들에 대해서 해당 기능을 적용할 수 있다. 또한 특정 변경 사항에 filter를 적용해 특정 변동에 한정해서 대응할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
 하지만 Change Stream을 적용하려면 MongoDB를 Replica Set으로 변경해야 한다. 따라서 이번 글에서는 DB를 &lt;strong&gt;Replica Set&lt;/strong&gt;으로 변경하는 방법에 대해 다루려고
 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-instance-replica-set으로-변경생성하기&quot;&gt;2. Instance Replica Set으로 변경/생성하기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1) 실행 중인 Stand alone Instance를 shutdown(프로세스 종료)한다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use admin  // admin database에 대하여 shutdown 명령어를 실행해야 한다는 점에 유의해야 한다
db.shutdownServer()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--Replica Set&lt;/code&gt; 옵션을 추가하여 인스턴스를 다시 실행한다.&lt;/p&gt;

&lt;p&gt;아래의 명령어를 실행해서 Stand alone instance를 Replica Set의 멤버로 다시 실행한다. 
이 때 dbpath를 파라미터로 전달해주어야 한다. 기존 Stand alone Instance의 경로를 적거나, 새로 인스턴스 파일을 만들 경우 storage로 사용할 새로운 파일의 경로를 적는다. 주의해야 할 점은 별도의 파일 설정을 해주지 않았다면, 현재 인스턴스의 default path는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'data/db'&lt;/code&gt;라는 점이다. 따라서 현재 인스턴스를 Replica Set으로 변경하고 싶은 경우 path에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'C:\data\db'&lt;/code&gt; 명시하면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --port 27017 --dbpath /srv/mongodb/db0 --replSet rs0 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3) Replica Set을 초기화한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rs.initiate()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-service로-변경한-instance-실행하기&quot;&gt;3. Service로 변경한 Instance 실행하기&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Replica Set으로 인스턴스를 변경한 후 프로젝트를 실행하면서 곤혹스러웠던 점은 컴퓨터를 재부팅할 경우 기존 Instance를(내 경우에는 default path의 Instance) Stand alone으로 재실행 한다는 것이었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --dbpath /srv/mongodb/db0 --replSet rs0 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 매번 path를 지정해주면서 ReplSet으로 실행시킬 수 있다. 하지만 프로젝트 과정에서 별도의 설정없이 mongodb를 사용했다면 이러한 과정은 매우 불편할 것이다.
따라서 부팅시 원하는 Instance를 실행하기 위해서 &lt;strong&gt;Window Service&lt;/strong&gt;를 변경하는 과정이 필요하다. 아래의 과정은 &lt;strong&gt;관리자 권한&lt;/strong&gt;으로 cmd를 실행한 후 따라하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;1) MongoDB 서비스 종료하기&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;net stop MongoDB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2) &lt;strong&gt;mongod.cfg&lt;/strong&gt; 파일에서 path 수정 (새로 Replica Set 디렉토리를 설정한 경우에만)&lt;/p&gt;

&lt;p&gt;mongod.cfg 파일은 MongoDB 폴더의 하위 폴더인 bin 파일에 존재한다. 주의해야 할 점은 mongoDB를 실행할 때 자동으로 config파일의 설정 사항을 반영하지 않는다는 점이다. config 파일의 내용이 아니라 default로 설정되어 있는 설정에 따라 동작하기 때문이다. 따라서 아래의 과정을 통해 mongod.cfg파일의 path를 변경했다 할지라도 다음 번 실행시에 어떠한 변화도 일어나지 않는다. 실행 시 별도의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--config&lt;/code&gt; 옵션을 통해 사용할 config 파일의 경로를 명시해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Where and how to store data.
storage:
  dbPath: C:\data\db1 //이 부분을 원하는 path로 변경한다. 
  journal:
    enabled: true

# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path:  C:\Program Files\MongoDB\Server\4.0\log\mongod.log // log파일의 경로도 별도로 설정해 줄 수 있다.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3) 기존 mongoDB 서비스를 제거한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --remove
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;4) 새로운 Service를 정의한 후 실행한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--config&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--replSet&lt;/code&gt; 옵션을 통해 config에 지정된 path의 Instance를 rs0이라는 ReplSet으로 실행하는 서비스를 설치할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --config &quot;C:\etc\mongod.cfg&quot; --replSet rs0 --install --serviceName &quot;MongoDB&quot;
net start MongoDB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-추가내용&quot;&gt;4. 추가내용&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 과정을 모두 마치면 부팅시 변경 사항을 토대로 새로운 Instance를 실행하게 된다. 기존의 자료를 생성한 디렉토리로 옮기고자 하는 경우 기존 디렉토리에 있는 파일들을 옮겨 넣으면 된다.&lt;/p&gt;

&lt;p&gt;프로젝트에서 노드를 사용하기 때문에 덧붙이자면, ReplSet DB와 node.js를 연결하고자 하는 경우 아래와 같이 URL에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?replicaSet=rs0(이름)&lt;/code&gt;을 더해주면 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Mongo(&quot;mongodb://localhost:27017/demo?replicaSet=rs0&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>react 시작</title>
   <link href="http://localhost:4000/react/2019/01/08/react-intro/"/>
   <updated>2019-01-08T00:00:00+09:00</updated>
   <id>http://localhost:4000/react/2019/01/08/react intro</id>
   <content type="html">&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;React의 장점 :&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1) 모든 것이 자바스크립트 기반이다.
 react는 프레임워크가 아니라 UI 라이브러리이다. 따라서 Angular와 같이 특정 프레임워크에 종속되는 언어를 배울 필요가 없다. react는 모든 것이 자바스크립트 기반이기 때문에 여러 프로젝트를 진행할수록 자바스크립트 프로그래머로서 한층 더 뛰어난 역량을 개발할 수 있게 된다. 무엇보다 웹 페이지를 제작하는데 있어 좀 더 빠르고 쉽게 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2) Composition 구조 
 웹 페이지를 구성하는 각 부분을 독립적으로 개발할 수 있으며 이를 component라고 한다. 이미 만든 특정 기능 혹은 뷰를 중복해서 구현해야 할 때 기존 component를 그대로 가져다 사용하면 되기 때문에 코드 재사용이 용이해진다. 또한 각 독립적인 부분을 합쳐 큰 단위의 컴포넌트를 쉽게 만들 수 있고 각 부분이 독립적이기 때문에 코드를 관리하는 측면에서도 큰 장점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3) Virtual DOM 활용
 React는 virtual Dom을 활용하여 DOM을 다루는 데 발생하는 비용을 줄인다. Dom은 복잡한 트리구조의 형태를 갖고 있기 때문에, 광범위한 Dom구조의 조작은 큰 성능 저하를 야기하고, 결국 해당 서비스는 좋지 못한 사용자 경험을 제공하게 된다.
React는 Virtual Dom을 활용하여 여러 방법 중 비용을 최소화하는 방법을 찾아내고 이를 실제 Dom에 반영하게 된다. 이는 성능의 개선과 함께 매끄러운 사용자 경험을 제공하는데 기여하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;4) 커뮤니티가 방대하다&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;5) react는 view이기 때문에 다른 언어(python 등)와 함께 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 5가지 외에도 많은 장점이 존재할 것이고, 또한 언급하진 않았지만 단점 또한 있을 것이다. 왜 react를 사람들이 많이 사용하는지가 궁금해서 인터넷을 통해 장점을 간단히 살펴봤다. 머리로 아는 것도 중요하지만, 무엇보다 직접 다양한 언어나 프레임워크 혹은 라이브러리를 사용해보고 부딪혀보면서 서로의 장단점을 비교할 수 있는 안목을 키우는 것이 좋을 것 같다는 생각이든다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>python 백준 코드순위 확인 프로그램</title>
   <link href="http://localhost:4000/python/2018/11/29/baekjoonCrawling/"/>
   <updated>2018-11-29T00:00:00+09:00</updated>
   <id>http://localhost:4000/python/2018/11/29/baekjoonCrawling</id>
   <content type="html">&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-코드-&quot;&gt;1. 코드 :&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import requests
from bs4 import BeautifulSoup



# 전체 : -1, C : 0 ,C++14 : 88, C++11 : 75, Java : 3, Python 3 : 28 등등

def getList(question_num,lan_code,my_id):

    url = 'https://www.acmicpc.net/problem/status'
    page = 1
    
    while 1:
        request = requests.get( url+'/'+ str(question_num) + '/' +str(lan_code) + '/' + str(page)) 

        # 페이지가 존재하지 않는 경우    
        if request.status_code != 200:
            print (&quot;아이디가 존재하지 않습니다&quot;)
            break
            
        print (&quot;현재 페이지 : &quot; + str (page))    
        
        soup = BeautifulSoup(request.text,'html.parser')
        table_structure = soup.select('body &amp;gt; div.wrapper &amp;gt; div.container.content &amp;gt; div.row &amp;gt; div.col-md-10 &amp;gt; div.table-responsive &amp;gt; table &amp;gt; tbody')
        lines = table_structure[0].find_all('tr')

        # 점수 table의 row에서 자신의 ID를 찾고, 페이지와 순위를 반환
        for each in lines:
            elements = each.find_all('td')
            user = elements[3].find('a').text
            if user == my_id :
                print ({'페이지' : page, '순위' : elements[0].text})
                return 
                
        page += 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getList(10988,28,'yjs08090')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;현재 페이지 : 1
현재 페이지 : 2
현재 페이지 : 3
현재 페이지 : 4
현재 페이지 : 5
현재 페이지 : 6
현재 페이지 : 7
현재 페이지 : 8
현재 페이지 : 9
현재 페이지 : 10
{'페이지': 10, '순위': '195'}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-설명&quot;&gt;2. 설명&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
온라인 저지 문제에 익숙하지 않았을 때는 단순히 문제를 푸는 것에 의미를 두었다. 어느 정도 문제를 푸는 것에 적응이 된 만큼, 이제 부터는 효율성을 고려한 코드를 작성하기 위해 노력해야 된다고 생각한다.온라인 저지에서 내 코드의 질을 판단하는 방법은 바로 순위를 확인하는 것이다. 실행 시간, 메모리의 효율적인 사용을 고민하며 순위를 높이는 것도 나름의 쾌감이 있다. 이 과정에서 다른 사람의 코드를 보면서 항상 새로운 방법의 풀이가 있음을 알게 된다. 다른 사람의 풀이를 참고하면서 다양하게 생각하는 방법과 어떤 경우에 어떤 라이브러리나 메소드를 쓰면 효과적인지 배울 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
하지만 참여자가 많은 문제와 프로그래밍 언어의 경우에는 코드 순위가 몇번째 인지 알기가 어렵다. 검색 기능이 별도로 존재하지 않기 때문에 수시로 찾아야 하는 번거로움이 있다. 이러한 과정을 자꾸 반복하다 보니 슬슬 시간이 아깝다는 생각을 하게 됐고, 예전에 크롤링 관련 프로젝트를 진행해봤기 때문에 이를 활용해 간단한 프로그램을 만들어 보고자 했다. 특정 백준 문제에서 자신이 제출한 코드의 순위를 반환해주는 아주 간단한 프로그램이다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;웹 서버에 HTTP 요청을 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;requests&lt;/code&gt;와 HTML 또는 XML 파일에서 파싱을 통해 정보를 추출하는 데 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;beautifulsoup&lt;/code&gt;를 활용했다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getList(question_num,lan_code,my_id)&lt;/code&gt;에서 볼 수 있듯이 getList 함수에 확인하고자 하는 문제 번호, 프로그래밍 언어 코드, 자신의 아이디 이렇게 3가지를 전달해 주면 된다. 코드 주석에는 필자 기준 주로 사용하는 언어 몇 가지 언어에 대한 코드만을 적어놨다. 자신이 사용하는 언어가 없는 경우, 백준 사이트 ‘맞은 사람’ 탭에서 언어를 바꿔준 후 url에서 언어 코드를 확인하면 된다. https://www.acmicpc.net/problem/status/10988/3/1를 예로 들면, 맨 뒤는 현재 페이지, 바로 왼쪽 3은 JAVA를 나타낸다. 위에서 언급한 3가지 파라미터를 전달해주면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getList&lt;/code&gt;함수는 현재 페이지 수와 코드 순위를 반환하게 된다. 
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>백준(4811) 알약</title>
   <link href="http://localhost:4000/algorithm/2018/11/28/%EB%B0%B1%EC%A4%804811/"/>
   <updated>2018-11-28T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/11/28/백준4811</id>
   <content type="html">&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-문제&quot;&gt;1. 문제&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/problem/4811&quot;&gt;백준 알약 문제(4811)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;문제를 요약하자면 먼저 병에는 N개의 알약이 존재한다. 하루에 반알씩 약을 복용해야 한다. 한 알 전체를 꺼낼 경우 반으로 쪼갠 후 나머지 조각을 병에 다시 넣고, 반 조각을 꺼낼 경우 그 약을 먹는다. 이때 한 조각을 꺼낼 경우 W, 반 조각을 꺼낼 경우 H를 종이에 기록한다. 2N일이 지났을 때 가능한 서로 다른 문자열의 개수를 구해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-코드-python-3&quot;&gt;2. 코드 (Python 3)&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sys
input=sys.stdin.readline
dp  = [[1]*31 if i == 0 else [0]*31 for i in range (31)]
m = 30

for i in range (1,31):
  for j in range(m):
    if j == 0:
      dp[i][0] = dp[i-1][1]
    else:
      dp[i][j] = dp[i-1][j+1] + dp[i][j-1] 
  m-=1

n = int (input ())
while n != 0:  
  print (dp[n][0])
  n = int (input())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-풀이&quot;&gt;3. 풀이&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
문제가 재귀호출을 사용하는 문제로 분류되어 있어, 처음에는 단순 재귀호출을 사용하여 문제를 해결하고자 했다. 먼저 $F(N,M)$ 는 알약 N 조각과 2등분 된 알약 M 조각이 있을 때 만들어지는 서로 다른 문자열의 개수라고 하자. 만약 알약 통에 각각 N,M 개의 알약이 존재한다면, 등분 되지 않은 알약을 꺼내는 경우와 조각 난 알약을 꺼내는 경우로 나눌 수 있다. 따라서 아래와 같은 점화식을 세울 수 있다. 
&lt;br /&gt;&lt;/p&gt;

\[F(N,M) = F(N-1,M+1) + F(N,M-1)\]

&lt;p&gt;&lt;br /&gt;
처음에는 위 식에 따라 몇가지 조건식을 넣고 recursion 코드를 구현했더니, 중복되는 계산이 많아서 주어진 시간 안에 문제를 풀 수 없을 것 같았다. 따라서 DP를 사용했고 그 중에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bottom-up&lt;/code&gt; 방식으로 다시 문제를 풀게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

\[F(N,M) =
\begin{cases}
F(N-1,M+1),  &amp;amp; \text{if $N &amp;gt; 0$ and $M = 0 $}\\
1, &amp;amp; \text{if $N = 0$ and $M &amp;gt; 0$} \\
F(N-1,M+1) + F(N,M-1), &amp;amp; \text{if $N &amp;gt; 0$ and $M &amp;gt; 0$}
\end{cases}\]

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 식에 따라 2 X 2 배열을 생성하였고, 입력으로 N(30 이하 정수)이 주어질 때 마다 배열에서 해당 답인 DP[N][0] (나눠지지 않은 알약 N) 찾아서 출력하였다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-시간복잡도&quot;&gt;4. 시간복잡도&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;테스트케이스 수와 상관 없이 2차원 배열을 생성해야 하기 때문에 시간복잡도는 $O(N^2)$이다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Python call by reference, call by value에 대해</title>
   <link href="http://localhost:4000/python/2018/11/23/python2/"/>
   <updated>2018-11-23T00:00:00+09:00</updated>
   <id>http://localhost:4000/python/2018/11/23/python2</id>
   <content type="html">&lt;hr /&gt;

&lt;h2 id=&quot;1call-by-reference-call-by-value란&quot;&gt;1.Call by reference, Call by value란&lt;/h2&gt;

&lt;p&gt;함수의 호출 방법에는 크게 &lt;strong&gt;Call by reference&lt;/strong&gt;와 &lt;strong&gt;Call by value&lt;/strong&gt; 두 가지의 방식이 있습니다. Python의 경우를 살펴보기 전에 먼저 두가지 함수호출 방법 개념에 대해 간단히 살펴보겠습니다.  pointer의 개념을 처음 배울 때 주로 사용하는 c언어로 코드를 작성했습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void fun (int a){
  a = 0;
  printf(&quot;%d\n&quot;,a);
}

int main () {

  int a = 10;
  printf (&quot;%d\n&quot;,a);
  fun(a);
  printf(&quot;%d\n&quot;,a);

  return 0;
}

-&amp;gt;
10
0
10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;main 함수에서 선언한 정수 a를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun()&lt;/code&gt; 함수에 argument로 제공하였습니다. 하지만 출력 값을 확인해 보면 함수 내 변수 a와 함수 밖에 선언된 a의 값이 각각 0과 10으로 서로 다르다는 것을 확인할 수 있습니다. 이러한 차이는 Call by value방식의 특성에서 기인한 것인데, &lt;strong&gt;Call by value 는 함수를 호출할 때 argument의 복사된 값을 넘겨주는 것입니다.&lt;/strong&gt; 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun()&lt;/code&gt;함수 안의 a는 함수 밖의 a와 다른 메모리 공간을 점유하며, 단지 동일한 값만을 갖고 있습니다. 따라서 함수 안에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 0&lt;/code&gt;을 실행 했을 때 함수 안에있는 별도의 변수 a에 0이라는 값이 대입됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void fun (int *a){
  *a = 0;
}

int main () {
  
  int a = 10;
  printf (&quot;%d\n&quot;,a);
  fun(&amp;amp;a);
  printf(&quot;%d\n&quot;,a);

  return 0;
}

-&amp;gt;
10
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 예제는 Call by reference의 예시 코드입니다. 결론적으로,&lt;strong&gt;Call by reference는 함수를 호출할 때 argument의 location 즉 메모리 주소를 함수에 제공하는 것입니다.&lt;/strong&gt; 따라서 parameter로 해당 값이 저장된 메모리 공간에 접근하여 직접 값을 참조하거나 변경할 수 있습니다. 위에서 main함수의 정수 a값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fun()&lt;/code&gt; 실행 전후로 변경된 것을 통해 이러한 점을 쉽게 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-python에서의-함수-호출&quot;&gt;2. Python에서의 함수 호출&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
먼저 이해하기 위해 가장 중요한 2가지 사실에 대해 정리해보자면,
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Python 함수의 parameter는 object의 reference 복사값이다.(Call by value)) 
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Python의 자료형은 Mutable, Immutable 두가지로 나뉜다. (두 속성에 대해서는 &lt;a href=&quot;https://yujaeseo.github.io/python/2018/11/22/Python1/&quot;&gt;이전 포스트&lt;/a&gt;를 참조하시면 됩니다.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위의 사실에 따라 함수에 Mutable과 Immutable 자료형 중 어느 것을 넘겨주는지를 구분할 수 있어야 합니다. 먼저 Mutable object를 넘겨주는 경우에 대해서 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;--immutable&quot;&gt;- Immutable&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fun (a):
  print (id (a))

a = 12
print (id (a))
fun(a)

-&amp;gt;
139845275445344
139845275445344
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
위 코드를 통해 함수 안의 변수 a와 함수 안의 a는 동일한 obejct를 가리키고 있다는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fun (a):
  a = 14
  print (id(a))

a = 12
print (id (a))
fun(a)

-&amp;gt;
140341591808096
140341591808160
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
함수 안에서 parameter에 14라는 값을 할당했습니다. int는 Immutable 타입이기 때문에 a에 새롭게 생성된 객체 (14)의 reference값이 저장되었습니다. 그래서 함수 안에서 함수 밖에 있는 a Object의 값을 바꿀 수 없습니다. 다음은 Mutable의 경우에 대한 코드입니다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;-mutable&quot;&gt;-Mutable&lt;/h3&gt;

&lt;h3 id=&quot;데이터-추가&quot;&gt;데이터 추가&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fun (a):
  a.append('d')
  print (a)

a = ['a','b','c']
print (a)
fun(a)
print (a)

-&amp;gt;
['a', 'b', 'c']
['a', 'b', 'c', 'd']
['a', 'b', 'c', 'd']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
위의 코드에서 볼 수 있듯, 함수를 통해 함수 밖 a 변수 List에 새로운 요소를 추가했습니다. 이는 a 객체의 복사된 값이 전달된 것이 아니라, reference가 전달되었기 때문에 가능한 일입니다. 즉 Mutable의 경우는 함수 안에서 함수 밖 객체에 접근하여 값을 변경할 수 있습니다.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;reference변경&quot;&gt;reference변경&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fun (a):
  a = ['a','b','c','d']
  print (a)

a = ['a','b','c']
print (a)
fun(a)
print (a)

-&amp;gt;
['a', 'b', 'c']
['a', 'b', 'c', 'd']
['a', 'b', 'c']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 a 변수의 reference를 변경하는 경우 입니다. parameter a는 call by value이기 때문에, 즉 reference의 복사값이기 때문에 함수 밖 객체에 어떤 영향도 주지 않습니다. 함수 안 변수 a는 새로운 list의 reference를 담고 있는 것이며, 이 경우 함수 밖 변수 a를 변경할 수 없게 됩니다. 
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Python Mutable, Immutable 비교</title>
   <link href="http://localhost:4000/python/2018/11/22/Python1/"/>
   <updated>2018-11-22T00:00:00+09:00</updated>
   <id>http://localhost:4000/python/2018/11/22/Python1</id>
   <content type="html">&lt;hr /&gt;

&lt;h2 id=&quot;1-mutable-immutable-이란-&quot;&gt;1. Mutable, Immutable 이란 ?&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Python의 모든 것은 &lt;strong&gt;Object&lt;/strong&gt;이다. 따라서 모든 변수는 생성된 Object의 reference를 담게 된다. 예를들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X = 2&lt;/code&gt;라는 코드는 정수 2라는 값을 갖는 int class object의 reference를 변수 x에 넣는다는 의미이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mutable object는 그 값을 변경할 수 있다는 의미이며&lt;/strong&gt;, 반대로 &lt;strong&gt;Immutable object는 그 값을 바꿀 수 없다는 것을 의미한다&lt;/strong&gt;. 프로그래머가 정의한 class의 object는 일반적으로 mutable이다. 하지만 대표적인 python built-in class 중 int,float,bool,str,tuple,unicode 객체는 Immutable이고, list,set,dict 객체는 Mutable이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-코드를-통한-차이-확인&quot;&gt;2. 코드를 통한 차이 확인&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음은 Mutable과 Immutable의 차이를 보여주는 Code이다.아래에서 사용된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id()&lt;/code&gt;&lt;strong&gt;함수는 객체가 갖는 고유의 값(object가 저장된 메모리 값)을 반환한다.&lt;/strong&gt; 파이썬의 모든 object는 value, type, identity(id)를 갖는다. 또한 Id는 객체가 생성될 때 부여되며 절대 변하지 않는 값이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 10
print (x)
print (id(x))
x += 1
print (x)
print (id(x))


-&amp;gt; 
10
140242833553440
11
140242833553472
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위에서 출력 값에서 x의 id 값이 변경된 것을 확인할 수 있다. int는 immutable 이기 때문에 값을 바꿀 수 없으므로 11이라는 값을 담은 새로운 int 형 object가 만들어 진다. 그리고 이 obejct의 reference가 x에 대입된 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;y = ['a','b']
print (y)
print (id(y))
y.append('c')
print (y)
print (id(y))


-&amp;gt;
['a', 'b']
140242795187592
['a', 'b', 'c']
140242795187592
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;List는 대표적인 mutable object이다. 따라서 list에 새로운 값(‘c’)을 넣어도 y에 기존의 reference가 유지되고, 출력 값을 확인해 보면 list에 ‘c’가 추가된 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-예외&quot;&gt;3. 예외&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t = ('abc',[1,2,3])
print (t[1])
t[1].append(4)
print (t[1])

-&amp;gt; 
[1, 2, 3]
[1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위의 코드를 보면 Tuple 자료형 안 List에 정수 4가 추가된 것을 확인할 수 있다. 하지만 초반에 Tuple은 Immutable 자료형으로, 그 값을 변경할 수 없다고 한 것과 모순되는 결과라고 생각할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t = ('abc',[1,2,3])
print (t[0])
t[0] = 'xyz'
print (t[0])

-&amp;gt; 
TypeError: 'tuple' object does not support item assignment

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Tuple에 저장된 String 값의 변경을 시도했을 때 위와 같은 에러가 발생한다. &lt;strong&gt;Tuple은 Immutable하기 때문에 값을 변경할 수 없기 때문이다.&lt;/strong&gt; 그러면 List 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;append()&lt;/code&gt;를 사용해서 정수 4를 추가한 것은 어떻게 설명할 수 있을까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t = ('ab','cd',[1,2,3])
print(t)
print(id(t[0]),id(t[1]),id(t[2]),sep=' ')

t[2].append(100)
print(t)
print(id(t[0]),id(t[1]),id(t[2]),sep=' ')

-&amp;gt;
('ab', 'cd', [1, 2, 3])
139797887251320 139797887251880 139797883936392
('ab', 'cd', [1, 2, 3, 100])
139797887251320 139797887251880 139797883936392
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tuple을 Immutable하다고 할 때 우리는 객체(tuple)에 binding된 객체(string 등)가 같은지를 판단해야 한다.&lt;/strong&gt; 위의 코드에서 확인할 수 있듯 Tuple 객체 안에 있는 list 값을 변경했지만(100 추가) List object의 id값은 유지되고 있음을 알 수 있다. &lt;strong&gt;즉 Mutable object인 list는 이전과 동일한 객체이며, 단지 객체의 value만 바뀐 것이다.&lt;/strong&gt; Tuple은 함수 실행 전과 동일한 객체(id)를 저장하고 있기 때문에 Immutable하다고 할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>백준(1157) 단어공부</title>
   <link href="http://localhost:4000/algorithm/2018/11/18/%EB%B0%B1%EC%A4%801157/"/>
   <updated>2018-11-18T00:00:00+09:00</updated>
   <id>http://localhost:4000/algorithm/2018/11/18/백준1157</id>
   <content type="html">&lt;hr /&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-코드&quot;&gt;1. 코드&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
python3 :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import Counter

def main ():

    inpStr = input().upper()    
    c = Counter(inpStr)
    
    if len(inpStr) == 1:
        print(inpStr)
        return 
    
    # O(n logk)
    res = c.most_common(2)
    
    if res[0][1] == res[1][1]  : 
        print ('?')
    else : 
        print (res[0][0])
    
    return

main()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-풀이&quot;&gt;2. 풀이&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
Collections 패키지의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;most_common()&lt;/code&gt; 메소드를 사용하여 풀이하였다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Counter()&lt;/code&gt;를 이용해 문자열의 알파벳과 빈도에 관한 정보를 담은 dictionary 자료형을 만든다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;most_common()&lt;/code&gt; 메소드에 파라미터로 2를 주면 가장 빈도가 높은 두 개의 알파벳과 그에 대응하는 빈도수 정보를 담은 tuple list가 주어진다. 1,2위 단어의 발생 빈도가 같은 경우 가장 많이 사용된 알파벳이 여러개 존재하는 경우이므로 ‘?’를 출력한다. 그렇지 않은 경우 가장 빈도수가 높은 알파벳 대문자를 출력한다. 주의할 점은 문자열이 알파벳 하나로 이루어졌을 경우인데, 이 경우 허용된 인덱스 값을 벗어나므로 별도로 처리해야된다. 
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-시간복잡도&quot;&gt;3. 시간복잡도&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt; 
-&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;most_common(k)&lt;/code&gt;의 시간 복잡도가 O(n logk)이다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-참고자료&quot;&gt;4. 참고자료&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;
1) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;most_common()&lt;/code&gt; 시간복잡도
&lt;a href=&quot;https://stackoverflow.com/questions/29240807/python-collections-counter-most-common-complexity&quot;&gt;https://stackoverflow.com/questions/29240807/python-collections-counter-most-common-complexity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2) 위의 자료를 이해하기 위해선 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;heapq&lt;/code&gt;자료형의 구현 에 대해 알아야 한다.
&lt;a href=&quot;https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l203&quot;&gt;https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l203&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;heapq.nlargest()&lt;/code&gt;와 관련된 자료이다.
&lt;a href=&quot;https://stackoverflow.com/questions/38806202/whats-the-time-complexity-of-functions-in-heapq-library&quot;&gt;https://stackoverflow.com/questions/38806202/whats-the-time-complexity-of-functions-in-heapq-library&lt;/a&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
